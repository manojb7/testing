#!/usr/bin/env python3
"""
Deploy Gardener Shoot Cluster - Production version
"""

import os
import sys
import yaml
import inspect
import shutil
from pprint import pprint
from python_path import PythonPath

with PythonPath("../../../", relative_to=__file__):
  from library.python.lib import common, config as config_module, gardener, lscrypt
import landscape_tools

def create_simplified_template(shoot_yml_path):
    """Create a simplified AWS template directly"""
    simple_aws_template = """context: (( &temporary ( merge ) ))

apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: (( .context.config.cluster.name ))
  namespace: (( .context.gardener_namespace ))
spec:
  secretBindingName: (( .context.config.cluster.provider_secret ))
  cloudProfile:
    name: aws
  region: (( .context.imports.iaas_provider.landscape.region ))
  purpose: (( .context.config.cluster.purpose ))
  provider:
    type: aws
    controlPlaneConfig:
      apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
      cloudControllerManager:
        useCustomRouteController: true
      kind: ControlPlaneConfig
      storage:
        managedDefaultClass: true
    infrastructureConfig:
      apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
      kind: InfrastructureConfig
      networks:
        vpc:
          cidr: (( .context.config.cluster.cidr ))
        zones:
          - name: (( .context.imports.iaas_provider.landscape.region_zones_list.[0] ))
            workers: (( .context.config.cluster.aws_zones.[0].workers ))
            public: (( .context.config.cluster.aws_zones.[0].public ))
            internal: (( .context.config.cluster.aws_zones.[0].internal ))
          - name: (( .context.imports.iaas_provider.landscape.region_zones_list.[1] ))
            workers: (( .context.config.cluster.aws_zones.[1].workers ))
            public: (( .context.config.cluster.aws_zones.[1].public ))
            internal: (( .context.config.cluster.aws_zones.[1].internal ))
          - name: (( .context.imports.iaas_provider.landscape.region_zones_list.[2] ))
            workers: (( .context.config.cluster.aws_zones.[2].workers ))
            public: (( .context.config.cluster.aws_zones.[2].public ))
            internal: (( .context.config.cluster.aws_zones.[2].internal ))
    workers:
      - cri:
          name: containerd
        name: vmetrics
        machine:
          type: m5.2xlarge
          image:
            name: gardenlinux
            version: 1592.8.0
          architecture: amd64
        maximum: 6
        minimum: 3
        maxSurge: 3
        maxUnavailable: 1
        volume:
          type: gp3
          size: 100Gi
        zones:
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[0] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[1] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[2] ))
        systemComponents:
          allow: true
        updateStrategy: AutoRollingUpdate
      - cri:
          name: containerd
        name: otel-col
        machine:
          type: m5.xlarge
          image:
            name: gardenlinux
            version: 1592.8.0
          architecture: amd64
        maximum: 4
        minimum: 2
        maxSurge: 2
        maxUnavailable: 1
        volume:
          type: gp3
          size: 50Gi
        zones:
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[1] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[2] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[0] ))
        systemComponents:
          allow: true
        updateStrategy: AutoRollingUpdate
      - cri:
          name: containerd
        name: generic
        machine:
          type: m5.xlarge
          image:
            name: gardenlinux
            version: 1592.8.0
          architecture: amd64
        maximum: 4
        minimum: 2
        maxSurge: 2
        maxUnavailable: 1
        volume:
          type: gp3
          size: 40Gi
        zones:
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[2] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[1] ))
          - (( .context.imports.iaas_provider.landscape.region_zones_list.[0] ))
        systemComponents:
          allow: true
        updateStrategy: AutoRollingUpdate
    workersSettings:
      sshAccess:
        enabled: true
  kubernetes:
    version: (( .context.config.cluster.k8s_version ))
  dns:
    domain: (( .context.config.cluster.name "." .context.config.cluster.project_name ".shoot.canary.k8s-hana.ondemand.com" ))
  extensions: 
    - type: shoot-dns-service
      providerConfig:
        apiVersion: service.dns.extensions.gardener.cloud/v1alpha1
        kind: DNSConfig
        syncProvidersFromShootSpecDNS: true
    - type: shoot-cert-service
      providerConfig:
        apiVersion: service.cert.extensions.gardener.cloud/v1alpha1
        kind: CertConfig
        shootIssuers:
          enabled: true
  networking:
    type: calico
    providerConfig:
      overlay:
        enabled: false
    pods: 100.64.0.0/12
    nodes: (( .context.config.cluster.cidr ))
    services: 100.104.0.0/13
    ipFamilies:
      - IPv4
  maintenance:
    timeWindow:
      begin: 220000+0100
      end: 230000+0100
    autoUpdate:
      kubernetesVersion: true
      machineImageVersion: true
  monitoring:
    alerting:
      emailReceivers:
        - (( .context.config.cluster.user_email ))
  addons:
    kubernetesDashboard:
      enabled: false
      authenticationMode: token
    nginxIngress:
      enabled: false
      externalTrafficPolicy: Cluster"""
    
    # Write the simplified template directly to shoot.yml
    with open(shoot_yml_path, 'w') as f:
        f.write(simple_aws_template)
    
    print(f"Created simplified AWS template at {shoot_yml_path}")
    return True

def debug_config_object(config_object):
    """Debug helper to inspect config_object"""
    print("\n--- Config Object Attributes ---")
    for attr_name in dir(config_object):
        if attr_name.startswith("__"):
            continue
        try:
            attr_value = getattr(config_object, attr_name)
            if not callable(attr_value):
                print(f"  {attr_name}: {attr_value}")
        except Exception as e:
            print(f"  {attr_name}: Error accessing - {e}")
    
    print("\n--- Config Object Methods ---")
    for method_name in dir(config_object):
        if method_name.startswith("__"):
            continue
        attr = getattr(config_object, method_name)
        if callable(attr):
            print(f"  {method_name}()")

def main():
    print("\n=== [STEP 1] Create Template ===")
    # Get the path to shoot.yml
    deployment_dir = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
        "..", "..", "deployments", "cluster"
    )
    shoot_yml_path = os.path.join(deployment_dir, "shoot.yml")
    create_simplified_template(shoot_yml_path)
        
    print("\n=== [STEP 2] Load Config ===")
    try:
        config_object = config_module.Config()
        print("[SUCCESS] Config loaded successfully!")
        
        # Debug the config_object to see what attributes are available
        debug_config_object(config_object)
    except Exception as e:
        print(f"[ERROR] Config loading failed: {e}")
        exit(1)
    
    print("\n=== [STEP 3] Create Gardener Helper ===")
    # Get the namespace from context.yml if not available on config_object
    namespace = "garden-perftests"  # Default value
    ctx_path = os.path.join(os.path.dirname(deployment_dir), "cluster", "gen", "ctx.yml")
    if os.path.exists(ctx_path):
        try:
            with open(ctx_path, 'r') as f:
                ctx_data = yaml.safe_load(f)
                if 'context' in ctx_data and 'gardener_namespace' in ctx_data['context']:
                    namespace = ctx_data['context']['gardener_namespace']
                    print(f"Found namespace in ctx.yml: {namespace}")
        except Exception as e:
            print(f"Error reading context file for namespace: {e}")
    
    # Get the cluster name from config_object or ctx.yml
    cluster_name = None
    if hasattr(config_object, "cluster_name"):
        cluster_name = config_object.cluster_name
    else:
        if os.path.exists(ctx_path):
            try:
                with open(ctx_path, 'r') as f:
                    ctx_data = yaml.safe_load(f)
                    if ('context' in ctx_data and 'config' in ctx_data['context'] and 
                        'cluster' in ctx_data['context']['config'] and 'name' in ctx_data['context']['config']['cluster']):
                        cluster_name = ctx_data['context']['config']['cluster']['name']
                        print(f"Found cluster_name in ctx.yml: {cluster_name}")
            except Exception as e:
                print(f"Error reading context file for cluster_name: {e}")
    
    if cluster_name is None:
        cluster_name = "vm-mon"  # Default value
    
    # Initialize GardenerHelper
    if hasattr(config_object, "get_gardener_helper") and callable(getattr(config_object, "get_gardener_helper")):
        gardener_helper = config_object.get_gardener_helper()
        print("[INFO] gardener_helper initialized via config_object method")
    else:
        # Fallback if config_object doesn't have get_gardener_helper
        kubeconfig_path = config_object.kubeconfig_file_path if hasattr(config_object, "kubeconfig_file_path") else "/tmp/kubeconfig.monitoring.tmp"
        gardener_helper = gardener.GardenerHelper(kubeconfig_path, namespace, cluster_name)
        print(f"[INFO] gardener_helper initialized directly with namespace={namespace}, cluster_name={cluster_name}")
    
    print("\n=== [STEP 4] Write Kubeconfig ===")
    try:
        if hasattr(config_object, "write_kubeconfig_file") and callable(getattr(config_object, "write_kubeconfig_file")):
            config_object.write_kubeconfig_file()
            print(f"[INFO] Kubeconfig written to: {config_object.kubeconfig_file_path if hasattr(config_object, 'kubeconfig_file_path') else 'unknown path'}")
        else:
            print("[WARN] No write_kubeconfig_file method available")
    except Exception as e:
        print(f"[ERROR] Failed to write kubeconfig: {e}")
    
    print("\n=== [STEP 5] Deploy Shoot ===")
    with landscape_tools.color_output("green"):
        print(f"Deploying shoot from manifest: {config_object.rendered_shoot_path if hasattr(config_object, 'rendered_shoot_path') else shoot_yml_path}")
    
    # Exit early to test - remove this line when ready to deploy
    exit(0)
    
    # Use the appropriate path for the shoot manifest
    shoot_manifest_path = config_object.rendered_shoot_path if hasattr(config_object, 'rendered_shoot_path') else shoot_yml_path
    gardener_helper.create_shoot(shoot_manifest_path)

    print("[INFO] Polling shoot creation status...")
    creation_status = gardener_helper.poll_shoot_status(timeout=3000, interval=10)

    if creation_status is True:
        print("[INFO] Shoot created successfully!")

        # Get cluster info from config_object or defaults
        name = cluster_name
        
        # Get DNS domain
        domain = None
        if hasattr(config_object, "get_dns_domain") and callable(getattr(config_object, "get_dns_domain")):
            domain = config_object.get_dns_domain()
        else:
            # Try to construct domain from other attributes
            domain = f"{cluster_name}.perftests.shoot.canary.k8s-hana.ondemand.com"
        
        # Get kubeconfig using get_shoot_kubeconfig method
        try:
            kubeconfig_data, _ = gardener_helper.get_shoot_kubeconfig()
            kubeconfig = kubeconfig_data
        except AttributeError:
            # Fallback if get_shoot_kubeconfig is not available
            print("[WARN] Using get_kubeconfig fallback...")
            try:
                if hasattr(gardener_helper, "get_kubeconfig"):
                    kubeconfig = gardener_helper.get_kubeconfig()
                else:
                    kubeconfig = "Unable to retrieve kubeconfig"
            except Exception as e:
                print(f"[ERROR] Failed to get kubeconfig: {e}")
                kubeconfig = "Error retrieving kubeconfig"

        export = {
            "exports": {
                "clusters": [
                    {
                        "name": name,
                        "namespace": namespace,
                        "domain": domain,
                        "kubeconfig": kubeconfig,
                    }
                ]
            }
        }

        print("\n=== [STEP 6] Exporting Cluster Info ===")
        print(yaml.dump(export, default_flow_style=False, sort_keys=False))
        try:
            lscrypt.write("cluster", "export.yml", export)
            print("[INFO] Export written to lscrypt: cluster/export.yml")
        except Exception as e:
            print(f"[ERROR] Failed to write export: {e}")

    else:
        print("[ERROR] Shoot creation failed.")
        exit(1)

    print("\n=== [DONE] Cluster Deployment Completed ===")

if __name__ == "__main__":
    main()
